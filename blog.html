---
layout: default
title: Blog
permalink: /blog.html
---

<div class="blog-head">
    <h1 class="h1">Blog</h1>
    <div class="search-wrap">
        <form class="searchbar" role="search" aria-label="Search blog posts" onsubmit="return false;">
            <span class="icon">üîç</span>
            <input id="q" type="search" placeholder="Search posts" autocomplete="off" />
        </form>
    </div>
        </div>

        <!-- Tag Filter Bar (UNION) -->
        <form id="filters" class="tag-filter" aria-label="Filter posts by tag">
    <!-- Tags will be injected dynamically -->
            <button type="reset" class="tag reset">Reset</button>
        </form>

<section class="post-list" id="welcome-post"></section>
<section class="post-list" id="post-list">
    <!-- Posts will be injected from Jekyll collections -->
</section>

<script>
    // Menu toggle - remove duplicate since default layout handles it

    // Client-side search on blog list (searches titles, tags, and content)
    (function () {
        const q = document.getElementById('q');
        const list = document.getElementById('post-list');
        const welcome = document.getElementById('welcome-post');
        if (!q) return;
        
        // Store content for each post
        const postContentCache = new Map();
        
        // Fetch and cache content for all posts
        function fetchPostContent(url, postElement) {
            if (postContentCache.has(url)) return;
            
            fetch(url)
                .then(r => r.ok ? r.text() : Promise.reject())
                .then(html => {
                    const tmp = document.createElement('div');
                    tmp.innerHTML = html;
                    const entry = tmp.querySelector('article.entry') || tmp;
                    const text = (entry.textContent || '').trim();
                    postContentCache.set(url, text);
                    // Store in data attribute for search
                    postElement.setAttribute('data-content', text);
                })
                .catch(() => {
                    // If fetch fails, just set empty content
                    postContentCache.set(url, '');
                    postElement.setAttribute('data-content', '');
                });
        }
        
        function filter() {
            const term = q.value.trim().toLowerCase();
            if (!term) {
                // If no search term, show all posts
                const listEl = document.getElementById('post-list');
                const welcomeEl = document.getElementById('welcome-post');
                const allRows = [];
                if (listEl) {
                    allRows.push(...listEl.querySelectorAll('.post'));
                }
                if (welcomeEl) {
                    allRows.push(...welcomeEl.querySelectorAll('.post'));
                }
                allRows.forEach(r => {
                    r.style.removeProperty('display');
                });
                return;
            }
            
            // Re-query posts each time since they're dynamically rendered
            const listEl = document.getElementById('post-list');
            const welcomeEl = document.getElementById('welcome-post');
            
            // Collect all posts from both sections
            const allRows = [];
            if (listEl) {
                allRows.push(...listEl.querySelectorAll('.post'));
            }
            if (welcomeEl) {
                allRows.push(...welcomeEl.querySelectorAll('.post'));
            }
            
            // Also show/hide year headers based on whether any posts in that year match
            const yearHeaders = [];
            if (listEl) {
                yearHeaders.push(...listEl.querySelectorAll('.year'));
            }
            
            allRows.forEach(r => {
                const titleEl = r.querySelector('.post-title');
                const title = titleEl ? (titleEl.textContent || titleEl.innerText || '').trim() : '';
                const tags = (r.getAttribute('data-tags') || '').trim();
                const content = (r.getAttribute('data-content') || '').trim();
                
                // Build searchable text
                const hay = (title + ' ' + tags + ' ' + content).toLowerCase().replace(/\s+/g, ' ');
                const matches = hay.includes(term);
                
                // Show/hide the post - preserve original display style
                if (matches) {
                    r.style.removeProperty('display');
                } else {
                    r.style.display = 'none';
                }
            });
            
            // Show/hide year headers if all their posts are hidden
            yearHeaders.forEach(yearHeader => {
                let hasVisiblePost = false;
                let currentEl = yearHeader.nextElementSibling;
                while (currentEl && !currentEl.classList.contains('year')) {
                    if (currentEl.classList.contains('post') && currentEl.style.display !== 'none') {
                        hasVisiblePost = true;
                        break;
                    }
                    currentEl = currentEl.nextElementSibling;
                }
                yearHeader.style.display = hasVisiblePost ? '' : 'none';
            });
        }
        
        // Wait for posts to be rendered before setting up the filter
        // Use a more reliable approach: check periodically or wait for posts to appear
        function setupFilterAfterPostsLoad() {
            const listEl = document.getElementById('post-list');
            const welcomeEl = document.getElementById('welcome-post');
            const postsExist = (listEl && listEl.querySelectorAll('.post').length > 0) || 
                              (welcomeEl && welcomeEl.querySelectorAll('.post').length > 0);
            
            if (postsExist) {
                // Posts are loaded, set up the filter
                q.addEventListener('input', filter);
                // Also trigger filter on page load if there's a search term
                if (q.value.trim()) {
                    filter();
                }
            } else {
                // Check again after a short delay
                setTimeout(setupFilterAfterPostsLoad, 100);
            }
        }
        
        // Start checking for posts
        setupFilterAfterPostsLoad();
        
        // Pre-fetch content for all posts (including welcome post)
        setTimeout(() => {
            const welcome = document.getElementById('welcome-post');
            const allRows = [...list.querySelectorAll('.post')];
            if (welcome) {
                allRows.push(...welcome.querySelectorAll('.post'));
            }
            allRows.forEach(r => {
                const link = r.querySelector('.post-title');
                if (link) {
                    const url = link.getAttribute('href');
                    if (url) fetchPostContent(url, r);
                }
            });
        }, 500);
    })();

    (function () {
        // Get posts from Jekyll-generated data
        const posts = [
            {% for post in site.posts %}
            {
                title: {{ post.title | jsonify }},
                url: "{{ post.url | relative_url }}",
                date: "{{ post.date | date: '%Y-%m-%d' }}",
                {% if post.updated %}updated: "{{ post.updated | date: '%Y-%m-%d' }}",{% endif %}
                tags: {{ post.tags | jsonify }}
            }{% unless forloop.last %},{% endunless %}
            {% endfor %}
        ];
        
        const list = document.getElementById('post-list');
        const welcome = document.getElementById('welcome-post');
        const filters = document.getElementById('filters');
        
        if (!list || !filters) return;

        // Aggregate tag counts (exclude empty strings)
        const tagToCount = new Map();
        posts.forEach(p => (p.tags || []).forEach(t => {
            const k = String(t).trim();
            if (!k) return;
            tagToCount.set(k, (tagToCount.get(k) || 0) + 1);
        }));

        // Render tag checkboxes sorted by desc count, then alpha
        const sortedTags = [...tagToCount.entries()]
            .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
            .map(([name, count]) => ({ name, count }));

        const resetBtn = filters.querySelector('.reset');
        if (resetBtn) filters.removeChild(resetBtn);
        sortedTags.forEach(({ name, count }) => {
            const id = `tag-${name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`;
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = id;
            input.value = name.toLowerCase();
            const label = document.createElement('label');
            label.htmlFor = id;
            label.className = 'tag';
            label.textContent = `${name} (${count})`;
            filters.appendChild(input);
            filters.appendChild(label);
        });
        // Re-add reset at end and wire up behavior
        const reset = document.createElement('button');
        reset.type = 'reset';
        reset.className = 'tag reset';
        reset.textContent = 'Reset';
        filters.appendChild(reset);

        // Pull out the welcome post and render it separately
        const welcomePost = posts.find(p => p.url.includes('welcome'));
        const regularPosts = posts.filter(p => !p.url.includes('welcome'));

        if (welcomePost) {
            const h2 = document.createElement('h2');
            h2.className = 'year';
            h2.textContent = 'About My Blog';
            welcome.appendChild(h2);

            const art = document.createElement('article');
            art.className = 'post';
            const wd = new Date(welcomePost.date);
            const wfmt = new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            const wformatted = wfmt.format(wd);
            const wdateHTML = `<time class="post-date" datetime="${welcomePost.date}">${wformatted}</time>`;
            art.innerHTML = `
                <div class="post-head"><a class="post-title" href="${welcomePost.url}">${welcomePost.title}</a><span class="post-readtime" aria-label="Estimated read time"></span></div>
                ${wdateHTML}
            `;
            welcome.appendChild(art);

            // Compute read time for welcome post
            (async () => {
                try {
                    const r = await fetch(welcomePost.url);
                    if (!r.ok) throw new Error('failed');
                    const html = await r.text();
                    const tmp = document.createElement('div');
                    tmp.innerHTML = html;
                    const entry = tmp.querySelector('article.entry') || tmp;
                    const text = (entry.textContent || '').trim();
                    const words = text.split(/\s+/).filter(Boolean).length;
                    const minutes = Math.max(1, Math.ceil(words / 225));
                    const rt = art.querySelector('.post-readtime');
                    if (rt) rt.textContent = `¬∑ ${minutes} min read`;
                } catch (e) {
                    // ignore failures
                }
            })();
        }

        let currentYear = null;
        const fmt = new Intl.DateTimeFormat(undefined, { month: 'short', day: 'numeric' });
        regularPosts.forEach(p => {
            const d = new Date(p.date);
            const year = d.getFullYear();
            if (year !== currentYear) {
                currentYear = year;
                const h2 = document.createElement('h2');
                h2.className = 'year';
                h2.textContent = String(year);
                list.appendChild(h2);
            }
            const art = document.createElement('article');
            art.className = 'post';
            art.setAttribute('data-tags', (p.tags || []).map(t => t.toLowerCase()).join(' '));
            const dateHTML = `<time class="post-date" datetime="${p.date}">${fmt.format(d)}</time>`;
            const readHTML = `<span class="post-readtime" aria-label="Estimated read time"></span>`;
            const tagsHTML = p.tags && p.tags.length ? 
                `<ul class="taglist">${p.tags.map(t => `<li>${t}</li>`).join('')}</ul>` : '';
            art.innerHTML = `
                <div class="post-head"><a class="post-title" href="${p.url}">${p.title}</a>${readHTML}</div>
                ${dateHTML}
                ${tagsHTML}
            `;
            list.appendChild(art);

            // Compute read time asynchronously
            (async () => {
                try {
                    const r = await fetch(p.url);
                    if (!r.ok) throw new Error('failed');
                    const html = await r.text();
                    const tmp = document.createElement('div');
                    tmp.innerHTML = html;
                    const entry = tmp.querySelector('article.entry') || tmp;
                    const text = (entry.textContent || '').trim();
                    const words = text.split(/\s+/).filter(Boolean).length;
                    const minutes = Math.max(1, Math.ceil(words / 225));
                    const rt = art.querySelector('.post-readtime');
                    if (rt) rt.textContent = `¬∑ ${minutes} min read`;
                } catch (e) {
                    // ignore failures
                }
            })();
        });

        function applyFilter() {
            const selected = [...filters.querySelectorAll('input[type="checkbox"]:checked')]
                .map(i => i.value);
            const rows = [...list.querySelectorAll('.post')];
            if (selected.length === 0) {
                rows.forEach(r => r.style.display = 'grid');
                return;
            }
            rows.forEach(r => {
                const tags = (r.getAttribute('data-tags') || '').split(/\s+/);
                const show = selected.some(s => tags.includes(s));
                r.style.display = show ? 'grid' : 'none';
            });
        }

        filters.addEventListener('change', applyFilter);
        filters.addEventListener('reset', function () {
            setTimeout(applyFilter, 0);
        });
        applyFilter();

        // Function to select tag from hash
        function selectTagFromHash() {
            const hash = window.location.hash;
            if (hash && hash.startsWith('#tag-')) {
                const tagId = hash.substring(1); // Remove the #
                const checkbox = document.getElementById(tagId);
                if (checkbox) {
                    checkbox.checked = true;
                    applyFilter();
                    // Scroll to filters section
                    setTimeout(() => {
                        const filterEl = document.getElementById('filters');
                        if (filterEl) {
                            filterEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    }, 100);
                    return true;
                }
            }
            return false;
        }

        // Check for tag filter in URL hash and auto-select it
        // Wait a bit for filters to be fully rendered
        setTimeout(selectTagFromHash, 100);

        // Handle hash changes
        window.addEventListener('hashchange', function() {
            // Uncheck all first
            filters.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            applyFilter();
            // Then select new tag
            setTimeout(selectTagFromHash, 50);
        });

        // Handle clicks on tag links (both in post pages and blog listing)
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('tag-link')) {
                const href = e.target.getAttribute('href');
                if (href && href.startsWith('#tag-')) {
                    e.preventDefault();
                    const tagId = href.substring(1);
                    const checkbox = document.getElementById(tagId);
                    if (checkbox) {
                        checkbox.checked = true;
                        applyFilter();
                        window.location.hash = tagId;
                        setTimeout(() => {
                            const filterEl = document.getElementById('filters');
                            if (filterEl) {
                                filterEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }, 100);
                    }
                }
            }
        });
    })();
</script>

